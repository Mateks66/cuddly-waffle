<!--
HTML5 Pong
Single-file game: open this .html in a browser to play.
Controls:
  - Player 1: W (up), S (down)
  - Player 2: Arrow Up, Arrow Down
  - Space: Pause / Serve
  - R: Reset scores
Features:
  - Responsive canvas
  - Simple AI (if Player 2 is idle)
  - Score to 10 wins
  - Smooth movement and collision
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HTML5 Pong</title>
  <style>
    :root{--bg:#0d1117;--fg:#e6edf3;--accent:#00d4ff}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg),#07101a);color:var(--fg)}
    .wrap{width:min(1000px,96vw);aspect-ratio:16/9;display:flex;flex-direction:column;gap:12px}
    canvas{width:100%;height:100%;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    .hud{display:flex;justify-content:space-between;align-items:center;color:var(--fg)}
    .controls{font-size:13px;opacity:0.9}
    .score{font-weight:700;font-size:18px;color:var(--accent)}
    .footer{display:flex;justify-content:center;gap:12px;color:#9fb3c6;font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="controls">Player 1: W / S</div>
      <div class="score" id="score">0 &nbsp; - &nbsp; 0</div>
      <div class="controls">Player 2: ↑ / ↓</div>
    </div>

    <canvas id="c"></canvas>

    <div class="footer">
      <div>Space: Serve / Pause</div>
      <div>R: Reset</div>
      <div id="status">Play!</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // Resize handling (high-DPI aware)
    function resize(){
      const ratio = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * ratio);
      canvas.height = Math.floor(canvas.clientHeight * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Game variables
    const PADDLE_W = 12;
    const PADDLE_H = 90;
    const BALL_SIZE = 12;
    const SPEED = 8; // base speed scalar

    const state = {
      p1: {x:20, y: (canvas.height/2)/ (window.devicePixelRatio||1) - PADDLE_H/2, vy:0},
      p2: {x: null, y: (canvas.height/2)/ (window.devicePixelRatio||1) - PADDLE_H/2, vy:0},
      ball: {x:0,y:0,vx:0,vy:0},
      score: [0,0],
      running: false,
      paused: false,
      winner: null,
      bestOf: 10,
      aiEnabled: true,
      aiDifficulty: 0.12 // 0..1 faster tracks
    };

    function initPositions(){
      const H = canvas.height / (window.devicePixelRatio||1);
      state.p1.y = H/2 - PADDLE_H/2;
      state.p1.x = 20;
      state.p2.x = (canvas.clientWidth) - 20 - PADDLE_W;
      state.p2.y = H/2 - PADDLE_H/2;
      resetBall();
    }

    function resetBall(servingTo = null){
      const W = canvas.clientWidth;
      const H = canvas.height / (window.devicePixelRatio||1);
      state.ball.x = W/2 - BALL_SIZE/2;
      state.ball.y = H/2 - BALL_SIZE/2;
      const angle = (Math.random()*Math.PI/3) - Math.PI/6; // -30..+30 degrees
      const dir = servingTo === 1 ? -1 : (servingTo === 2 ? 1 : (Math.random()<0.5 ? 1 : -1));
      const speed = SPEED * (1 + Math.random()*0.4);
      state.ball.vx = dir * Math.cos(angle) * speed;
      state.ball.vy = Math.sin(angle) * speed;
    }

    // Input
    const keys = {};
    window.addEventListener('keydown', e=>{
      keys[e.key.toLowerCase()] = true;
      if(e.key === ' '){
        e.preventDefault();
        if(!state.running) { state.running = true; state.paused = false; state.winner = null; }
        else state.paused = !state.paused;
      }
      if(e.key.toLowerCase() === 'r') resetGame();
    });
    window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

    function resetGame(){
      state.score = [0,0];
      state.winner = null;
      state.running = false;
      state.paused = false;
      initPositions();
      updateHUD();
    }

    function updateHUD(){
      document.getElementById('score').textContent = `${state.score[0]} \u00A0 - \u00A0 ${state.score[1]}`;
      const status = document.getElementById('status');
      if(state.winner) status.textContent = `Player ${state.winner} wins! Press R to restart.`;
      else if(!state.running) status.textContent = 'Press Space to serve';
      else if(state.paused) status.textContent = 'Paused';
      else status.textContent = 'Play!';
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function step(dt){
      if(!state.running || state.paused || state.winner) return;
      const H = canvas.height / (window.devicePixelRatio||1);
      // Player 1 control W/S
      let p1vy = 0;
      if(keys['w']) p1vy = -10;
      else if(keys['s']) p1vy = 10;
      else p1vy = 0;
      state.p1.y += p1vy;
      state.p1.y = clamp(state.p1.y, 0, H - PADDLE_H);

      // Player 2 control Up/Down
      let p2Controlled = false;
      if(keys['arrowup']){ state.p2.y -= 10; p2Controlled = true; }
      if(keys['arrowdown']){ state.p2.y += 10; p2Controlled = true; }
      if(p2Controlled){ state.aiEnabled = false; }
      state.p2.y = clamp(state.p2.y, 0, H - PADDLE_H);

      // Simple AI when enabled
      if(state.aiEnabled){
        const center = state.ball.y + BALL_SIZE/2;
        const target = center - PADDLE_H/2;
        // Move towards target with easing based on difficulty
        state.p2.y += (target - state.p2.y) * state.aiDifficulty * Math.min(1, dt*60/1000);
        state.p2.y = clamp(state.p2.y, 0, H - PADDLE_H);
      }

      // Ball movement
      state.ball.x += state.ball.vx * (dt/16.67);
      state.ball.y += state.ball.vy * (dt/16.67);

      // Collide top/bottom
      if(state.ball.y <= 0){ state.ball.y = 0; state.ball.vy *= -1; }
      if(state.ball.y + BALL_SIZE >= H){ state.ball.y = H - BALL_SIZE; state.ball.vy *= -1; }

      // Paddle collisions
      // p1
      if(state.ball.x <= state.p1.x + PADDLE_W && state.ball.x >= state.p1.x){
        if(state.ball.y + BALL_SIZE >= state.p1.y && state.ball.y <= state.p1.y + PADDLE_H){
          // hit
          state.ball.x = state.p1.x + PADDLE_W;
          reflectFromPaddle(state.p1);
        }
      }
      // p2
      if(state.ball.x + BALL_SIZE >= state.p2.x && state.ball.x + BALL_SIZE <= state.p2.x + PADDLE_W){
        if(state.ball.y + BALL_SIZE >= state.p2.y && state.ball.y <= state.p2.y + PADDLE_H){
          state.ball.x = state.p2.x - BALL_SIZE;
          reflectFromPaddle(state.p2, true);
        }
      }

      // Score
      const W = canvas.clientWidth;
      if(state.ball.x + BALL_SIZE < 0){ // player 2 scores
        state.score[1]++;
        checkScore();
        resetBall(2);
      }
      if(state.ball.x > W){ // player 1 scores
        state.score[0]++;
        checkScore();
        resetBall(1);
      }

      updateHUD();
    }

    function reflectFromPaddle(paddle, towardLeft=false){
      // Increase speed slightly
      const relativeY = (state.ball.y + BALL_SIZE/2) - (paddle.y + PADDLE_H/2);
      const normalized = relativeY / (PADDLE_H/2); // -1 .. 1
      const maxBounce = Math.PI/3; // 60 degrees
      const angle = normalized * maxBounce;
      const speed = Math.min(20, Math.hypot(state.ball.vx, state.ball.vy) * 1.06);
      const dir = towardLeft ? -1 : 1;
      // If paddle is on the right, reflect left (dir = -1)
      state.ball.vx = dir * Math.cos(angle) * speed * (towardLeft ? -1 : 1);
      state.ball.vy = Math.sin(angle) * speed;
    }

    function checkScore(){
      const win = Math.max(state.score[0], state.score[1]) >= state.bestOf;
      if(win){ state.winner = state.score[0] > state.score[1] ? 1 : 2; state.running = false; }
    }

    // Render
    function draw(){
      const W = canvas.clientWidth;
      const H = canvas.height / (window.devicePixelRatio||1);
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // background subtle grid
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0,0,W,H);

      // middle dashed line
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 2;
      ctx.setLineDash([14,12]);
      ctx.beginPath();
      ctx.moveTo(W/2,10);
      ctx.lineTo(W/2,H-10);
      ctx.stroke();
      ctx.setLineDash([]);

      // paddles
      ctx.fillStyle = '#e6edf3';
      roundRect(ctx, state.p1.x, state.p1.y, PADDLE_W, PADDLE_H, 6);
      roundRect(ctx, state.p2.x, state.p2.y, PADDLE_W, PADDLE_H, 6);

      // ball
      ctx.beginPath();
      ctx.fillStyle = '#00d4ff';
      ctx.arc(state.ball.x + BALL_SIZE/2, state.ball.y + BALL_SIZE/2, BALL_SIZE/2, 0, Math.PI*2);
      ctx.fill();

      // scores (big center)
      ctx.fillStyle = 'rgba(230,237,243,0.08)';
      ctx.font = '80px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(state.score[0], W*0.35, 100);
      ctx.fillText(state.score[1], W*0.65, 100);

      // small top HUD handled by DOM
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      ctx.fill();
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = now - last;
      last = now;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Initialize
    function start(){
      initPositions();
      // Small kickoff pause state
      state.running = false;
      state.paused = false;
      updateHUD();
      requestAnimationFrame(loop);
    }

    start();

    // Keep canvas positions in sync on start/resize
    window.addEventListener('load', ()=>{ initPositions(); updateHUD(); });

    // Touch support: tap left/right to move paddle towards touch
    let touchId = null;
    canvas.addEventListener('touchstart', e=>{
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;
      // If touch near left half, control player 1
      if(x < rect.width/2){
        state.p1.y = clamp(y - PADDLE_H/2, 0, rect.height - PADDLE_H);
      } else {
        state.p2.y = clamp(y - PADDLE_H/2, 0, rect.height - PADDLE_H);
        state.aiEnabled = false;
      }
      e.preventDefault();
    }, {passive:false});

    canvas.addEventListener('touchmove', e=>{
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = t.clientX - rect.left;
      const y = t.clientY - rect.top;
      if(x < rect.width/2){ state.p1.y = clamp(y - PADDLE_H/2, 0, rect.height - PADDLE_H); }
      else { state.p2.y = clamp(y - PADDLE_H/2, 0, rect.height - PADDLE_H); state.aiEnabled = false; }
      e.preventDefault();
    }, {passive:false});

    // Make canvas size responsive to CSS size
    const resizeObserver = new ResizeObserver(()=>{ resize(); initPositions(); });
    resizeObserver.observe(canvas);

  </script>
</body>
</html>
